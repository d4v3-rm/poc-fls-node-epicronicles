Ecco un **mini-manuale di comportamento** che un’AI deve seguire mentre sviluppa questo gioco, dato lo stack e le regole che hai scelto.

---

## 1. Vincoli hard sullo stack

1.1 **L’AI deve usare solo:**

* **TypeScript**
* **Vite** come bundler/dev server
* **React** per la UI
* **Three.js** per la grafica 3D
* **Zustand** per lo stato globale
* **JSON** per configurazione e dati di gioco

1.2 **L’AI non deve:**

* Introdurre pattern OOP nel codice applicativo (niente `class` per la logica di gioco).
* Aggiungere nuove librerie senza che l’utente lo chieda esplicitamente.
* Usare JavaScript “puro” al posto di TypeScript nei file del progetto.

---

## 2. Paradigma funzionale + React (no OOP)

2.1 **Componenti React**

* Devono essere **sempre** function component (`function MyComponent() { ... }` o arrow).
* Vietato usare class component (`class MyComponent extends React.Component {}`).
* La logica interna dei componenti deve essere strutturata in **hook custom** e funzioni pure riutilizzabili.

2.2 **Logica di dominio**

* La logica del gioco (calcolo risorse, aggiornamento empire, simulazione turni/tick, ecc.) deve essere scritta con:

  * **funzioni pure** che ricevono uno stato e ritornano un nuovo stato,
  * tipi/`interface` TypeScript per descrivere i dati.
* Non devono esistere classi tipo `class Empire { ... }`, `class Galaxy { ... }` per la logica.

  * Se Three.js richiede `new THREE.Scene()`, `new THREE.Mesh()`, questo è ammesso **solo** come integrazione con la libreria, non come pattern interno dell’app.

2.3 **Side-effects**

* Tutti gli effetti collaterali (I/O, accesso a `localStorage`, fetch JSON, timer, ecc.) devono essere:

  * incapsulati in **hook React** (`useEffect`, hook custom),
  * oppure in **funzioni che ritornano Promises** richiamate dai componenti/hook.
* È vietato manipolare direttamente il DOM (niente `document.getElementById` ecc.), a meno che non sia strettamente necessario per integrare Three.js, e comunque incapsulato in un componente.

---

## 3. Niente spaghetti code, solo “gnocchi code”

*Definizione operativa di “gnocchi code” per l’AI: codice a pezzetti piccoli, compatti, ben formati e facili da combinare.*

3.1 **Organizzazione del codice**

* Ogni file deve avere **una responsabilità chiara**:

  * es. `galaxy/generateGalaxy.ts`, `empire/updateResources.ts`, `ui/GalaxyMap.tsx`, ecc.
* Evitare file “Dio” da centinaia di righe che fanno di tutto.
* Funzioni al massimo di poche decine di righe; se crescono, l’AI deve proporre un refactor in funzioni più piccole.

3.2 **Separation of concerns**

* La logica di simulazione (calcolo stato di gioco) non deve stare dentro i componenti React.

  * I componenti usano funzioni da moduli tipo `domain/galaxy`, `domain/empire`.
* La UI non deve conoscere dettagli interni dei dati oltre a quelli esposti dal tipo/selector.

3.3 **Refactor proattivo**

* Se una porzione di codice si ripete, l’AI **deve**:

  * estrarla in una funzione/utility,
  * oppure in un componente React riutilizzabile,
  * oppure in un hook custom.
* Niente copia-incolla di “blocchi simili ma non uguali” → sempre cercare di unificarli con parametri.

---

## 4. TypeScript: tipato, non “any-land”

4.1 **Regole generali**

* **`strict` deve essere attivo** in `tsconfig.json`.
* Vietato usare `any` se non come ultima risorsa in un refactor temporaneo (e va poi rimosso).
* È preferibile usare:

  * `unknown` + type guard,
  * tipi unione,
  * `interface`/`type` per modelli di dominio.

4.2 **Modelli di dominio**

* Tutti i concetti dell’SRS devono avere un tipo esplicito:

  * `Galaxy`, `StarSystem`, `Planet`, `Empire`, `Fleet`, ecc.
* I tipi dei dati JSON devono essere definiti come `type`/`interface` e, se possibile, derivati dal JSON stesso.

4.3 **Sicurezza con JSON**

* Ad ogni lettura di JSON esterno, l’AI deve:

  * definire un tipo atteso,
  * validare i dati in ingresso (anche con check manuali se non si usa una libreria di schema),
  * non usare `as any` sui dati di gioco.

---

## 5. Stato globale con Zustand

5.1 **Uso di Zustand**

* Tutto lo **stato di gioco mutabile** condiviso (galassia, imperi, flotte, impostazioni) deve essere gestito tramite uno o più store Zustand.
* React Context globale è permesso solo per casi molto specifici (es. tema, localizzazione), non per lo stato di gioco.

5.2 **Struttura dello store**

* Lo store deve essere definito come **funzione pura che ritorna uno state object** + metodi, es:

  ```ts
  type GameState = {
    galaxy: Galaxy;
    empires: Empire[];
    tick: number;
    // ...
    advanceTick: () => void;
  };
  ```

* Gli “updater” (tipo `advanceTick`) devono:

  * leggere lo stato corrente,
  * chiamare funzioni pure di dominio (es. `computeNextGameState`),
  * scrivere il risultato nello store.

5.3 **Selectors**

* I componenti React devono usare **selector** di Zustand (`useGameStore(state => state.galaxy)`), non accedere allo store completo se non necessario.
* Se l’AI vede che un componente legge troppi campi dallo store, deve proporre di split-tare le responsabilità.

---

## 6. Integrazione Three.js

6.1 **Isolamento della parte 3D**

* Tutta la logica 3D deve essere raggruppata in:

  * componenti React dedicati (es. `<GalaxyScene />`),
  * moduli di utilità per creare/aggiornare scene, materiali, mesh.
* Nessun componente generico di UI deve contenere direttamente codice Three.js.

6.2 **Pattern d’uso**

* Setup scena:

  * creare `Scene`, `Camera`, `Renderer` una sola volta per container.
  * gestire lifecycle in **hook React** (`useEffect` + `useRef`).
* Aggiornamento scena:

  * leggere lo stato (Zustand) e aggiornare oggetti 3D in funzioni separate.
  * evitare logica di gioco direttamente dentro il loop di render.

6.3 **Side-effect controllati**

* Il loop di animazione (`requestAnimationFrame`) deve essere avviato e fermato in modo controllato (cleanup in `useEffect`).
* Nessun accesso non controllato al DOM fuori dal container del canvas.

---

## 7. Configurazione & personalizzazione via JSON

7.1 **Niente hardcode di dati di gioco**

* Ogni dato di design che possa ragionevolmente cambiare deve stare in JSON:

  * configurazione galassia (dimensioni, densità),
  * definizione tipi di pianeta, razze, tratti,
  * tabelle di bilanciamento (costi, produzione, ecc.),
  * definizione di eventi, tecnologie, tradizioni.

7.2 **Schema dei JSON**

* L’AI deve:

  * proporre una struttura di directory chiara (`config/galaxy.json`, `config/empirePresets.json`, `config/events/*.json`, …),
  * definire tipi TS corrispondenti (`GalaxyConfig`, `EventDefinition`, ecc.).
* Quando modifica la struttura di un JSON, l’AI deve aggiornare i tipi TS e i punti di utilizzo.

7.3 **Caricamento e override**

* Il caricamento della configurazione deve avvenire:

  * una volta all’avvio (o al caricamento di una partita) tramite funzioni ben definite,
  * popolando lo stato iniziale nel store Zustand.
* Se l’AI introduce override (es. modding), deve farlo con funzioni pure tipo:

  ```ts
  const mergedConfig = mergeConfig(baseConfig, userConfig);
  ```

---

## 8. Stile del codice e struttura del progetto

8.1 **Struttura consigliata**

L’AI deve tendere a organizzare il progetto in cartelle tipo:

* `src/domain` – logica di gioco pura (nessun React).
* `src/store` – store Zustand e selettori.
* `src/components` – UI React (2D, pannelli, HUD).
* `src/three` – integrazione 3D (scene, helpers).
* `src/config` – tipi e loader per JSON.
* `src/utils` – utility generiche.

8.2 **Naming & consistenza**

* Nomi chiari e semantici (`updateEmpireResources`, `generateRandomGalaxy`, `FleetOverviewPanel`).
* L’AI deve mantenere uno stile coerente già in uso nel repo (camelCase, PascalCase, ecc.).
* Niente abbreviazioni criptiche (`fn1`, `calcStuff`).

8.3 **Pulizia**

* Vietato lasciare codice morto/non usato; l’AI deve rimuoverlo o commentare che è temporaneo.
* Vietato lasciare `console.log` permanenti in codice di produzione (solo log strutturati, se previsti).

---

## 9. Comportamento dell’AI quando scrive/modifica codice

9.1 **Quando aggiunge file o moduli**

* Deve:

  * spiegare brevemente lo scopo del file,
  * indicare da dove viene usato,
  * mostrare eventuali dipendenze da JSON/config.

9.2 **Quando tocca parti delicate**

* Se modifica logica di simulazione, deve:

  * mantenere la purezza delle funzioni di dominio,
  * aggiornare i test (se presenti) o proporre casi di test.

9.3 **Quando vede violazioni delle regole**

* Se nel codice esistente ci sono:

  * classi OOP per logica di gioco,
  * uso massivo di `any`,
  * spaghetti code in componenti enormi,
    l’AI deve proporre:
  * un piano di refactor incrementale,
  * modifiche compatibili con lo stato attuale del progetto.

---

Se vuoi, nel messaggio dopo possiamo:

* trasformare queste regole in un **documento `AI_GUIDELINES.md`** pronto da mettere nel repo, oppure
* scrivere uno scheletro di progetto (`src/` con cartelle e file vuoti/tipo) già allineato a queste regole.
